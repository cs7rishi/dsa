7001. BFS || Easy
TC: O(2E+N) // we visit each node twice, from either side parent-child and child-parent
SC: O(3N)

    public ArrayList<Integer> bfsOfGraph(ArrayList<ArrayList<Integer>> adj) {
        int n = adj.size();
        boolean isVisited[] = new boolean[n];
        
        Queue<Integer> q = new LinkedList<>();
        q.add(0);
        isVisited[0] = true;
        
        ArrayList<Integer> ans = new ArrayList<>();
        
        while(!q.isEmpty()){
            int node = q.poll();
            ans.add(node);    
            for(Integer t : adj.get(node)){
                if(!isVisited[t]){
                    q.add(t);
                    isVisited[t] = true;
                }
            }
        }
        
        return ans;
    }

7002. DFS || EASY
TC: O(2E+N) // we visit each node twice, from either side parent-child and child-parent
SC: O(3N)
class Solution {
    ArrayList<Integer> ans = new ArrayList<>();
    public void dfs(ArrayList<ArrayList<Integer>> adj, int node, boolean[] isVisited){
        if(isVisited[node]) return;
        ans.add(node);
        isVisited[node] = true;
        for(int t : adj.get(node)){
            dfs(adj, t, isVisited);
        }
    }
    public ArrayList<Integer> dfsOfGraph(ArrayList<ArrayList<Integer>> adj) {
        int n = adj.size();
        boolean[] isVisited = new boolean[n];
        dfs(adj, 0, isVisited);
        return ans;
    }
}

7003. Number of provinces || EASY
TC: O(N) + O(2E+N) // we visit each node twice, from either side parent-child and child-parent
SC: O(N)
class Solution {
    private void bfs (int node, boolean[] isVisited, int[][] isConnected){
        int n = isVisited.length;
        Queue<Integer> q = new LinkedList<>();
        q.add(node);
        isVisited[node] = true;
        while(!q.isEmpty()){
            int t = q.poll();
            for(int i = 0; i < n ; i++){
                if(isConnected[t][i] == 1 && !isVisited[i]){
                    q.add(i);
                    isVisited[i] = true;
                }
            }
        }
    }
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] isVisited = new boolean[n];
        int province = 0;
        for(int i = 0 ; i < n ; i++){
            if(!isVisited[i]){
                province++;
                bfs(i,isVisited, isConnected);
            }
        }
        return province;
    }
}

7004. Connected Components Problem in Matrix || EASY
TC: O(N) + O(2E+N) // we visit each node twice, from either side parent-child and child-parent
SC: O(N) + O(N) recursion

class Solution {
    static void dfs(int u, ArrayList<ArrayList<Integer>> adj , boolean[] isVisited){
        int n = isVisited.length;
        if(isVisited[u]) return;
        
        isVisited[u] = true;
        
        for(int i = 0 ; i < n ; i++){
            if(adj.get(u).get(i) == 1)
                dfs(i,adj,isVisited);
        }
    }
    static int numProvinces(ArrayList<ArrayList<Integer>> adj, int V) {
        boolean[] isVisited = new boolean[V];
        Queue<Integer> q = new LinkedList<>();
        int p = 0;
        for(int i = 0 ; i < V ; i++){
            if(!isVisited[i]){
                p++;
                dfs(i, adj, isVisited);
            }
        }
        
        return p;
    }
};

7005. Rotten Oranges || EASY
TC: O(4*N*M + N*M)
SC: O(N*M)
    public int orangesRotting(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int total = 0;
        int rotten = 0;
        Queue<Pair<Integer,Integer>> q = new LinkedList<>();
        for(int i = 0 ; i < m ; i++){
            for(int j = 0 ; j < n ; j++){
                if(grid[i][j] == 2){
                    q.add(new Pair(i,j));
                    total++;
                }
                else if(grid[i][j] == 1) total++;
            }
        } 

        if(rotten == total) return 0;

        int time = -1;
        int[] dx = new int[]{1,-1,0,0};
        int[] dy = new int[]{0,0,-1,1};

        while(!q.isEmpty()){
            int size = q.size();
            time++;
            while(size-- > 0){
                int row = q.peek().getKey();
                int col = q.peek().getValue();

                q.poll();
                rotten++;

                for(int k = 0 ; k < 4 ; k++){
                    int adjRow = row + dx[k];
                    int adjCol = col + dy[k];

                    if(adjRow >= 0 && adjRow < m && adjCol >= 0 && adjCol < n && grid[adjRow][adjCol] == 1){
                        grid[adjRow][adjCol] = 2;
                        q.add(new Pair(adjRow, adjCol));
                    }
                }
            }
        }
        return total == rotten ? time : -1;
    }

7006. Flood Fill || EASY || *
TC: O(4*N*M)
SC: O(N*M)
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        int m = image.length;
        int n = image[0].length;
        int initColor = image[sr][sc];

        Queue<Pair<Integer,Integer>> q = new LinkedList<>();
        q.add(new Pair(sr,sc));

        int[] dx = new int[]{1,-1,0,0};
        int[] dy = new int[]{0,0,-1,1};
        while(!q.isEmpty()){
            int row = q.peek().getKey();
            int col = q.peek().getValue();
            image[row][col] = color;
            q.poll();
            for(int k = 0 ; k < 4 ; k++){
                int adjRow = row + dx[k];
                int adjCol = col + dy[k];
                //************************************** below condition is important
                if(adjRow >= 0 && adjRow < m && adjCol >= 0 && adjCol < n && image[adjRow][adjCol] != color && image[adjRow][adjCol] == initColor){
                    q.add(new Pair(adjRow,adjCol));
                }
            }
        }
        return image;
    }

7007. 01 Matrix || EASY
TC: O(4*N*M + N*M)
SC: O(2*N*M)
    public int[][] updateMatrix(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;

        int[][] ans = new int[m][n];
        Queue<Pair<Integer,Integer>> q = new LinkedList<>();

        for(int i = 0 ; i < m ; i++){
            for(int j = 0 ; j < n ; j++){
                if(mat[i][j] == 1){
                    ans[i][j] = Integer.MAX_VALUE;
                }else{
                    q.add(new Pair(i,j));
                }
            }
        }

        int dist = 0;
        int[] dx = new int[]{1,-1,0,0};
        int[] dy = new int[]{0,0,-1,1};
        while(!q.isEmpty()){
            int size = q.size();
            dist++;
            while(size-- > 0){
                int row = q.peek().getKey();
                int col = q.peek().getValue();
                q.poll();

                for(int i = 0 ; i < 4 ; i++){
                    int adjRow = row + dx[i];
                    int adjCol = col + dy[i];

                    if(adjRow >= 0 && adjRow < m && adjCol >= 0 && adjCol < n && ans[adjRow][adjCol] > dist){
                        ans[adjRow][adjCol] = dist;
                        q.add(new Pair(adjRow, adjCol));
                    }
                }

            }
        }
        return ans;
    }

7008. Surrounded Regions || EASY
TC: O(4*N*M + N*M)
SC: O(4*N*M)

class Solution {
    private int[] dx = new int[]{1,-1,0,0};
    private int[] dy = new int[]{0,0,-1,1};
    private void dfs(char[][] board, int row, int col, int m, int n){
        if(row < 0 || col < 0 || row >= m || col >= n || board[row][col] == '#' || board[row][col] == 'X') return;

        board[row][col] = '#';
        for(int k = 0 ; k < 4 ; k++){
            int adjRow = row + dx[k];
            int adjCol = col + dy[k];
            dfs(board, adjRow, adjCol, m, n);
        }
    }
    public void solve(char[][] board) {
        int m = board.length;
        int n = board[0].length;

        for(int i = 0 ; i < m ; i++){
            if(board[i][0] == 'O'){
                dfs(board, i, 0, m , n);
            }

            if(board[i][n-1] == 'O'){
                dfs(board,i ,n-1, m, n);
            }
        }

        for(int j = 0 ; j < n ; j++){
            if(board[0][j] == 'O'){
                dfs(board, 0, j, m , n);
            }

            if(board[m-1][j] == 'O'){
                dfs(board, m-1, j, m, n);
            }
        }

        for(int i = 0 ; i < m ; i++){
            for(int j= 0 ; j < n ; j++){
                if(board[i][j] == '#'){
                    board[i][j] = 'O';
                }else{
                    board[i][j] = 'X';
                }
            }
        }
    }
}

7008. Number of Enclaves || EASY
TC: O(4*N*M) 
SC: O(N)
public int numEnclaves(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int count = 0;

        Queue<int[]> q = new LinkedList<>();

        for(int i = 0 ; i < m ; i++){
            for(int j = 0 ; j < n ; j++){
                if(grid[i][j] == 1){
                    count++;
                    if(i == 0 || i == m-1 || j == 0 || j == n-1){
                        q.add(new int[]{i,j});
                        count--;
                        grid[i][j] = 0;
                    } 
                }
            }
        }
        int[] dx = new int[]{1,-1,0,0};
        int[] dy = new int[]{0,0,-1,1};

        while(!q.isEmpty()){
            int row = q.peek()[0];
            int col = q.peek()[1];
            q.poll();

            for(int i = 0 ; i < 4 ; i++){
                int adjRow = row + dx[i];
                int adjCol = col + dy[i];

                if(adjRow < 0 || adjCol < 0 || adjRow >= m || adjCol >= n) continue;
                else if(grid[adjRow][adjCol] == 1){
                    grid[adjRow][adjCol] = 0;
                    count--;
                    q.add(new int[]{adjRow,adjCol});
                }
            }
        }

        return count;
    }

7009. Undirected Graph Cycle || EASY || Concept || *
TC: O(N + 2E) 
SC: O(N) + O(N) ~ O(N)
class Solution {
    boolean[] isVisited;
    public boolean dfs(int root, ArrayList<ArrayList<Integer>> adj, int parent){
        if(isVisited[root]) return true;
        isVisited[root] = true;
        boolean temp = false;
        for(int i = 0 ; i < adj.get(root).size() ; i++){
            if(!isVisited[adj.get(root).get(i)]){
                temp |= dfs(adj.get(root).get(i), adj, root);
            }else if(adj.get(root).get(i) != parent){
                temp |= true;
            }
        }
        return temp;
    }
    public boolean isCycle(ArrayList<ArrayList<Integer>> adj) {
        int n = adj.size();
        isVisited = new boolean[n];
        for(int i = 0 ; i < n ; i++){
            if(!isVisited[i] && dfs(i, adj, -1)){
                return true;
            }
        }
        return false;
    }
}

7010. Undirected Graph Cycle BFS || EASY || Concept || *
TC: O(N + 2E) 
SC: O(N) + O(N) ~ O(N)
class Solution {
    public boolean bfs(int root, ArrayList<ArrayList<Integer>> adj, boolean[] isVisited){
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{root, -1});
        isVisited[root] = true;
        
        while(!q.isEmpty()){
            int u = q.peek()[0];
            int parent = q.peek()[1];
            q.poll();
            
            for(int i = 0 ; i < adj.get(u).size(); i++){
                int v = adj.get(u).get(i);
                if(!isVisited[v]){
                    isVisited[v] = true;
                    q.add(new int[]{v,u});
                }else if(v != parent) return true;
            }
        }
        return false;
    }
    public boolean isCycle(ArrayList<ArrayList<Integer>> adj) {
        int n = adj.size();
        boolean[] isVisited = new boolean[n];
        for(int i = 0 ; i < n ; i++){
            if(!isVisited[i] && bfs(i, adj, isVisited)) return true;
        }
        return false;
    }
}

7011. Word Ladder || Medium || ***
TC: O(N*26) 
SC: O(N)
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> st = new HashSet<>(wordList);
        if(!st.contains(endWord)) return 0;
        Queue<Pair<String,Integer>> q = new LinkedList<>();
        q.add(new Pair(beginWord,1));
        while(!q.isEmpty()){
            String initWord = q.peek().getKey();
            int step = q.peek().getValue();
            q.poll();
            for(int i = 0 ; i < initWord.length() ; i++){
                char current = initWord.charAt(i);
                for(int j = 0 ; j < 26 ; j++){
                    char nextChar = (char)('a' + j);
                    if(current == nextChar) continue;
                    else {
                        char[] charArray = initWord.toCharArray();
                        charArray[i] = nextChar;
                        String newString = new String(charArray);
                        if(newString.equals(endWord)) return step+1;
                        if(st.contains(newString)){
                            st.remove(newString);
                            q.add(new Pair(newString, step+1));
                        }
                    }
                }
            }
        } 
        return 0;
    }

7013. Cycle Detection in Directed Graph (DFS) || Medium || ***
TC: O(V+E) + O(V) 
SC: O(2N) + O(N)

class Solution {
    private boolean isCycle(int node, ArrayList<Integer> ans, boolean[] isVisited, boolean[] isPath, ArrayList<ArrayList<Integer>> adjList){
        isVisited[node] = true;
        isPath[node] = true;

        for(int v : adjList.get(node)){
            if(isPath[v]){
                return true;
            }
            else if(!isVisited[v]){
                if(isCycle(v,ans,isVisited,isPath,adjList)){
                    return true;
                }
            }
        }

        ans.add(node);
        isPath[node] = false;
        return false;
    }
    public int[] findOrder(int numCourses, int[][] pre) {
        ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();
        for(int i = 0 ; i < numCourses ; i++) adjList.add(new ArrayList<>());

        for(int i = 0 ; i < pre.length; i++){
            int v = pre[i][0];
            int u = pre[i][1];

            adjList.get(u).add(v);
        }

        boolean isVisited[] = new boolean[numCourses];
        boolean path[] = new boolean[numCourses];
        boolean flag = false;
        ArrayList<Integer> ans = new ArrayList<>();

        for(int i = 0 ; i < numCourses ; i++){
            if(!isVisited[i]){
                if(isCycle(i,ans, isVisited, path, adjList)){
                    flag = true;
                    break;
                }
            }
        }

        if(flag == true){
            return new int[]{};
        }
        Collections.reverse(ans);
        int[] order = new int[numCourses];
        for(int i = 0 ; i < numCourses; i++){
            order[i] = ans.get(i);
        }
        return order;
    }
}


7014. Topo Sort DFS || Medium || ***
//DFS code
TC: O(V+E) + O(V) 
SC: O(2N) + O(N)

class Solution {
    // Function to return list containing vertices in Topological order.
    static void dfs(int node, boolean[] isVisited, Stack<Integer> st, ArrayList<ArrayList<Integer>> adj){
        isVisited[node] = true;
        for(int v : adj.get(node)){
            if(!isVisited[v]){
                dfs(v, isVisited, st, adj);
            }
        }
        st.add(node);
        
    }
    static ArrayList<Integer> topologicalSort(ArrayList<ArrayList<Integer>> adj) {
        int n = adj.size();
        boolean isVisited[] = new boolean[n];
        ArrayList<Integer> order = new ArrayList<>();
        Stack<Integer> st = new Stack<>();
        
        for(int i = 0 ; i < n ; i++){
            if(!isVisited[i]){
                dfs(i, isVisited, st, adj);
            }
        }
        
        while(!st.isEmpty()){
            order.add(st.pop());
        }
        
        return order;
        
    }
}

7015. Kahn's Algorithm || Medium || ***
TC: O(V+E) + O(V) 
SC: O(2N) + O(N) // Usually Striver don't consider space for ans, calculation

    static ArrayList<Integer> topologicalSort(ArrayList<ArrayList<Integer>> adj) {
        int n = adj.size();
        int[] inDegree = new int[n];
        Queue<Integer> q = new LinkedList<>();
        ArrayList<Integer> ans = new ArrayList<>();
        for(int i = 0 ; i < n ; i++){
            for(int v : adj.get(i)){
                inDegree[v]++;
            }
        }
        
        for(int i = 0 ; i < n ; i++){
            if(inDegree[i] == 0) q.add(i);
        }
        
        
        while(!q.isEmpty()){
            int u = q.poll();
            ans.add(u);
            
            for(int v : adj.get(u)){
                inDegree[v]--;
                
                if(inDegree[v] == 0)q.add(v);
            }
        }
        
        return ans;
    }

7017. Find eventual safe states || EASY || PENDING || *
TC: O(V+E) + O(VlogV) 
SC: O(N) Queue + O(N) inDegree + O(N) adjList

    public List<Integer> eventualSafeNodes(int[][] graph) {
        int n = graph.length;
        List<Integer> ans = new ArrayList<>();
        int[] inDegree = new int[n];
        List<List<Integer>> adjList = new ArrayList<>();
        for(int i = 0 ; i < n ; i++) adjList.add(new ArrayList<>());

        for(int u = 0 ; u < graph.length; u++){
            for(int j = 0 ; j < graph[u].length ; j++){
                int v = graph[u][j];
                adjList.get(v).add(u);
                inDegree[u]++;
            }
        }

        Queue<Integer> q = new LinkedList<>();
        for(int i = 0 ; i < n ; i++){
            if(inDegree[i] == 0) q.add(i);
        }

        while(!q.isEmpty()){
            int u = q.poll();
            ans.add(u);

            for(int v : adjList.get(u)){
                inDegree[v]--;
                if(inDegree[v] == 0) q.add(v);
            }
        }

        Collections.sort(ans);
        return ans;
    }

7019. Shortest Path in UG with unit weights || EASY
TC: O(N+2M)
SC: O(N+M) O(N) Queue + O(N) isVisite + O(N) distance
    public int[] shortestPath(int[][] edges,int n,int m ,int src) {
        ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();
        for(int i = 0 ; i < n ; i++) adjList.add(new ArrayList<>());
        
        for(int i = 0 ; i < edges.length; i++){
            int u = edges[i][0];
            int v = edges[i][1];
            
            adjList.get(u).add(v);
            adjList.get(v).add(u);
        }
        
        boolean isVisited[] = new boolean[n];
        int[] ans = new int[n];
        Queue<Integer> q = new LinkedList<>();
        
        Arrays.fill(ans,-1);
        ans[src] = 0;
        q.add(src);
        int dist = 0;
        
        while(!q.isEmpty()){
            int size = q.size();
            dist++;
            
            while(size-- > 0){
                int u = q.poll();
                isVisited[u] = true;
                for(int v : adjList.get(u)){
                    if(!isVisited[v]){
                        q.add(v);
                        isVisited[v] = true;
                        ans[v] = dist;
                    }    
                }
            }
        }
        
        return ans;
    }

7021. Djisktra's Algorithm || EASY || **
TC: O( E log(V) )
SC: O( |E| + |V| ) 
ArrayList<Integer> dijkstra(ArrayList<ArrayList<iPair>> adj, int src) {
        int INF = Integer.MAX_VALUE;
        int n = adj.size();
        
        ArrayList<Integer> ans = new ArrayList<>();
        for(int i = 0 ; i < n ; i++) ans.add(INF);
        
        boolean isVisited[] = new boolean[n];
        
        PriorityQueue<iPair> pq = new PriorityQueue<>((a,b) -> a.first - b.first);
        pq.add(new iPair(0,src));
        
        
        while(!pq.isEmpty()){
            int ud = pq.peek().first;
            int u = pq.peek().second;
            pq.poll();
            
            if(isVisited[u]) continue;
            isVisited[u] = true;
            ans.set(u,ud);
            
            
            for(iPair pair : adj.get(u)){
                int v = pair.first;
                int wt = pair.second;
                
                if(!isVisited[v] && ud + wt < ans.get(v)){
                    pq.add(new iPair(ud+wt, v));
                }
            }
        }
        
        return ans;
        
    }

7021. B
//Could remove isVisited from the code
//Code for Dense Graph
ArrayList<Integer> dijkstra(ArrayList<ArrayList<iPair>> adj, int src) {
        int INF = Integer.MAX_VALUE;
        int n = adj.size();
        
        ArrayList<Integer> ans = new ArrayList<>();
        for(int i = 0 ; i < n ; i++) ans.add(INF);
        
        PriorityQueue<iPair> pq = new PriorityQueue<>((a,b) -> a.first - b.first);
        pq.add(new iPair(0,src));
        ans.set(src,0);
        
        
        while(!pq.isEmpty()){
            int ud = pq.peek().first;
            int u = pq.peek().second;
            pq.poll();
            
            if(ud != ans.get(u)) continue;
            for(iPair pair : adj.get(u)){
                int v = pair.first;
                int wt = pair.second;
                if(ud + wt < ans.get(v)){
                    pq.add(new iPair(ud+wt, v));
                    ans.set(v,ud+wt);
                }
            }
        }
        
        return ans;
        
    }

7023. Shortest path in a binary maze || EASY || *
TC: O(N*M*8)
SC: O(N^2 + N)
public int shortestPathBinaryMatrix(int[][] grid) {
        int n = grid.length;
        int INF = Integer.MAX_VALUE;

        int[][] dist = new int[n][n];
        for(int[] t: dist) Arrays.fill(t,INF);

        Queue<Pair<Integer,Integer>> q = new LinkedList<>();
        if(grid[0][0] ==  0){
            q.add(new Pair(0,0));
            dist[0][0] = 1;
        }
        int[] dx = new int[]{0,1,0,-1,-1,1,1,-1};
        int[] dy = new int[]{1,0,-1,0,1,1,-1,-1};
        while(!q.isEmpty()){
                int row = q.peek().getKey();
                int col = q.peek().getValue();
                q.poll();

                for(int k = 0 ; k < 8 ; k++){
                    int adjRow = row + dx[k];
                    int adjCol = col + dy[k];

                    if(adjRow < 0 || adjCol < 0 || adjRow >= n || adjCol >= n || grid[adjRow][adjCol] == 1) continue;
                    else if(dist[adjRow][adjCol] > dist[row][col] + 1){
                        dist[adjRow][adjCol] = dist[row][col]+1;
                        q.add(new Pair(adjRow,adjCol));
                    }
                }
        }

        return dist[n-1][n-1] == INF ? -1 : dist[n-1][n-1];
    }

7024. Path with minimum effort || EASY 
TC: O(N*M*4 log( N*M))
SC: O(N*M)

    public int minimumEffortPath(int[][] heights) {
        int n = heights.length;
        int m = heights[0].length;

        int[][] effort = new int[n][m];
        for(int[] t : effort) Arrays.fill(t, Integer.MAX_VALUE);
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0] - b[0]);
        pq.add(new int[]{0,0,0});
        effort[0][0] = 0;

        int dx[] = new int[]{1,-1,0,0};
        int dy[] = new int[]{0,0,-1,1};

        while(!pq.isEmpty()){
            int e = pq.peek()[0];
            int row = pq.peek()[1];
            int col = pq.peek()[2];
            pq.poll();

            if(row == n-1 && col == m-1) return e;
            if(e != effort[row][col]) continue;

            for(int k = 0 ; k < 4 ; k++){
                int adjRow = row + dx[k];
                int adjCol = col + dy[k];

                if(adjRow < 0 || adjCol < 0 || adjRow >= n || adjCol >= m) continue;
                else if(effort[adjRow][adjCol] > Math.max(e,Math.abs(heights[row][col] - heights[adjRow][adjCol]))){
                    int newEffort = Math.max(e,Math.abs(heights[row][col] - heights[adjRow][adjCol]));
                    effort[adjRow][adjCol] = newEffort;
                    pq.add(new int[]{newEffort, adjRow, adjCol});

                }
            }
        }
        return effort[n-1][m-1];
    }

7025. Cheapest flights within k stops || EASY || *

7025.A.
TC: O(Mlog(N))
SC: O(M + N)
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        int INF = -1;
        List<List<Pair<Integer,Integer>>> adjList = new ArrayList<>();
        for(int i = 0 ; i < n ; i++) adjList.add(new ArrayList<>());

        for(int i = 0 ; i < flights.length ; i++){
            int u = flights[i][0];
            int v = flights[i][1];
            int wt = flights[i][2];
            adjList.get(u).add(new Pair(v,wt));
        }

        int[] minPrice = new int[n];
        Arrays.fill(minPrice, INF);
        minPrice[src] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]);
        pq.add(new int[]{0,src,0});

        while(!pq.isEmpty()){
            int[] ele = pq.poll();
            int stop = ele[0];
            int u = ele[1];
            int uPrice = ele[2];

            if(stop > k) continue;

            for(Pair<Integer,Integer> p : adjList.get(u)){
                int v = p.getKey();
                int wt = p.getValue();
                if(minPrice[v] == INF || minPrice[v] > uPrice + wt){
                    minPrice[v] = uPrice + wt;
                    pq.add(new int[]{stop+1,v,uPrice+wt});
                }
            }
        }
        return minPrice[dst];
    }

7025.B. Using Queue
TC: O(N)
SC: O(M + N)
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        int INF = -1;
        List<List<Pair<Integer,Integer>>> adjList = new ArrayList<>();
        for(int i = 0 ; i < n ; i++) adjList.add(new ArrayList<>());

        for(int i = 0 ; i < flights.length ; i++){
            int u = flights[i][0];
            int v = flights[i][1];
            int wt = flights[i][2];
            adjList.get(u).add(new Pair(v,wt));
        }

        int[] minPrice = new int[n];
        Arrays.fill(minPrice, INF);
        minPrice[src] = 0;

        Queue<int[]> pq = new LinkedList<>();
        pq.add(new int[]{0,src,0});

        while(!pq.isEmpty()){
            int[] ele = pq.poll();
            int stop = ele[0];
            int u = ele[1];
            int uPrice = ele[2];

            if(stop > k) continue;

            for(Pair<Integer,Integer> p : adjList.get(u)){
                int v = p.getKey();
                int wt = p.getValue();
                if(minPrice[v] == INF || minPrice[v] > uPrice + wt){
                    minPrice[v] = uPrice + wt;
                    pq.add(new int[]{stop+1,v,uPrice+wt});
                }
            }
        }
        return minPrice[dst];
    }

7026. Network Delay time || EASY 

7026.A. Bellman Ford
TC: O(N*M)
SC: O(N)

    public int networkDelayTime(int[][] times, int n, int k) {
        int INF = -1;
        int[] d = new int[n];
        Arrays.fill(d,INF);
        d[k-1] = 0;

        for(int i = 0 ; i < n ; i++){
            for(int j = 0 ; j < times.length ; j++){
                int u = times[j][0]-1;
                int v = times[j][1]-1;
                int wt = times[j][2];

                if(d[u] != INF && (d[v] == INF || d[v] > d[u] + wt)){
                    d[v] = d[u] + wt;
                }
            }
        }

        int mx = 0;
        for(int t : d){
            if(t == -1) return -1;
            mx = Math.max(mx, t);
        }
        return mx;
    }

7026.A. Djisktra
TC: O(MlogV + M + N + N)
SC: O(N + M + N(minTIme) + N(Queue))

    public int networkDelayTime(int[][] times, int n, int k) {
        int INF = -1;
        k--;
        List<List<Pair<Integer,Integer>>> adjList = new ArrayList<>();
        for(int i = 0 ; i < n ; i++) adjList.add(new ArrayList<>());
        for(int j = 0 ; j < times.length ; j++){
            int u = times[j][0]-1;
            int v = times[j][1]-1;
            int wt = times[j][2];

            adjList.get(u).add(new Pair<>(v,wt));
        }

        int[] minTime = new int[n];
        Arrays.fill(minTime,INF);
        minTime[k] = 0;
        
        PriorityQueue<Pair<Integer,Integer>> pq = new PriorityQueue<>((a,b)->a.getKey() - b.getKey());
        pq.add(new Pair(0,k));

        while(!pq.isEmpty()){
            int t = pq.peek().getKey();
            int u = pq.peek().getValue();
            pq.poll();

            for(Pair<Integer,Integer> p : adjList.get(u)){
                int v = p.getKey();
                int wt = p.getValue();

                if(minTime[v] == INF || minTime[v] > t + wt){
                    minTime[v] = t + wt;
                    pq.add(new Pair(minTime[v], v));
                }
            }
        }

        int mx = 0;
        for(int t : minTime){
            if(t == -1) return -1;
            mx = Math.max(mx,t);
        }

        return mx;
    }

7027. Number of ways to arrive at destination || Medium || ***
TC: O(ElogV)
SC: O(N)

    public int countPaths(int n, int[][] roads) {
        int INF = Integer.MAX_VALUE;
        int MOD = 1000_000_007;
        int[] distance = new int[n];
        int[] ways = new int[n];

        Arrays.fill(distance,INF);
        distance[0] = 0;
        ways[0] = 1;

        List<List<Pair<Integer,Integer>>> adjList = new ArrayList<>();

        for(int i = 0 ; i < n ; i++) adjList.add(new ArrayList<>());
        for(int i = 0 ; i < roads.length ; i++){
            int u = roads[i][0];
            int v = roads[i][1];
            int wt = roads[i][2];

            adjList.get(u).add(new Pair(v,wt));
            adjList.get(v).add(new Pair(u,wt));
        }

        PriorityQueue<Pair<Integer,Integer>> pq = new PriorityQueue<>((a,b) -> a.getKey()-b.getKey());
        pq.add(new Pair(0,0));
        while(!pq.isEmpty()){
            int d = pq.peek().getKey();
            int u = pq.peek().getValue();
            pq.poll();

            for(Pair<Integer,Integer> p : adjList.get(u)){
                int v = p.getKey();
                int wt = p.getValue();
                if(d+wt < distance[v]){
                    distance[v] = d + wt;
                    ways[v] = ways[u] % MOD;

                    pq.add(new Pair(distance[v], v));
                }else if (d+wt == distance[v]){
                    ways[v] = (ways[v] + ways[u]) % MOD;
                }
            }
        }

        return ways[n-1];
    }

7028. Minimum steps to reach end from start by performing multiplication and mod operations with array elements || EASY || *
TC: O(10^5 * n)
SC: O(10^5 * n)
    int minimumMultiplications(int[] arr, int start, int end) {
        int MOD = 100_000;
        int n = arr.length;
        int[] step = new int[MOD+1];
        Arrays.fill(step,-1);
        
        Queue<int[]> pq = new LinkedList<>();
        pq.add(new int[]{0,start});
        
        while(!pq.isEmpty()){
            int moves = pq.peek()[0];
            int oldStart = pq.peek()[1];
            
            pq.poll();
            if(oldStart == end) return moves;
            
            for(int i = 0 ; i < arr.length ; i++){
                int newStart = (oldStart * arr[i]) % MOD;
                
                if(step[newStart] == -1 || step[newStart] > moves+1){
                    step[newStart] = moves+1;
                    pq.add(new int[]{moves+1,newStart});
                }
            }
        }
        
        return -1;
    }

7029. Bellman Ford || Fundamental || *
TC: O(V*E)
SC: O(V)
static int[] bellmanFord(int V, int[][] edges, int src) {
        int INF = 1000_000_00;
        int distance[] = new int[V];
        Arrays.fill(distance,INF);
        
        distance[src] = 0;
        boolean flag = false;
        for(int i = 0 ; i <= V ; i++){
            flag = false;
            for(int j = 0 ; j < edges.length ; j++){
                int u = edges[j][0];
                int v = edges[j][1];
                int wt = edges[j][2];
                if(distance[u] != INF && distance[v] > distance[u] + wt){
                    distance[v] = distance[u] + wt;
                    flag = true;
                }
            }
        }
        
        if(flag) return new int[]{-1};
        return distance;
        
    }

7030. Floyd Warshal Algorithm || Fundamental || *
TC: O(V^3)
SC: O(V^2)
    public void shortestDistance(int[][] mat) {
        int n = mat.length;
        int INF = Integer.MAX_VALUE;
        
        for(int i = 0 ; i < n ;i++){
            for(int j = 0 ; j < n ; j++){
                if(mat[i][j] == -1){
                    mat[i][j] = INF;
                }
            }
        }
        
        for(int k = 0 ; k < n ; k++){
            for(int i = 0 ; i < n ; i++){
                for(int j = 0 ; j < n ; j++){
                    if(mat[i][k] != INF && mat[k][j] != INF){
                        mat[i][j] = Math.min(mat[i][j],mat[i][k] + mat[k][j]);
                    }
                }
            }
        }
        
        for(int i = 0 ; i < n ;i++){
            for(int j = 0 ; j < n ; j++){
                if(mat[i][j] == INF){
                    mat[i][j] = -1;
                }
            }
        }
    }

7031. Find the city with the smallest number of neighbors in a threshold distance || EASY || *
TC: O(V^3)
SC: O(V^2)

public int findTheCity(int n, int[][] edges, int th) {
        int INF = Integer.MAX_VALUE;
        int[][] adjM = new int[n][n];
        for(int[] t: adjM) Arrays.fill(t, INF);
        for(int i = 0 ; i < edges.length; i++){
            int u = edges[i][0];
            int v = edges[i][1];
            int w = edges[i][2];

            adjM[u][v] = w;
            adjM[v][u] = w;
        }
        for(int k = 0 ; k < n ; k++){
            for(int i = 0 ; i < n ; i++){
                for(int j = 0 ; j < n ; j++){
                    if(adjM[i][k] != INF && adjM[k][j] != INF){
                        adjM[i][j] = Math.min(adjM[i][j] , adjM[i][k] + adjM[k][j]);
                    }
                }
            }
        }
        int ansCity = -1;
        int smallestReach = n+1;
        for(int i= 0 ; i < n ; i++){
            int tempReach = 0;
            for(int j = 0 ; j < n ; j++){
                if(i != j && adjM[i][j] <= th){
                    tempReach++;
                }
            }
            if(tempReach <= smallestReach){
                ansCity = i;
                smallestReach = tempReach;
            }
        }

        return ansCity;
    }

7032. Prim's Algorithm || Fundamental || *
TC: O(ElogE)
SC: O(E)Queue + O(V)isVisited  
    static int spanningTree(int V, int E, List<List<int[]>> adj) {
        
        PriorityQueue<Pair<Integer,Integer>> pq = new PriorityQueue<>((a,b)->a.getKey() - b.getKey());
        boolean isVisited[] = new boolean[V];
        
        pq.add(new Pair(0,0));
        int sum = 0;
        
        while(!pq.isEmpty()){
            int uWeight = pq.peek().getKey();
            int uNode = pq.peek().getValue();
            pq.poll();
                
            if(isVisited[uNode]) continue;
            isVisited[uNode] = true;
            sum += uWeight;
            
            for(int[] p : adj.get(uNode)){
                int vNode = p[0];
                int vWeight = p[1];
                
                if(!isVisited[vNode]){
                    pq.add(new Pair(vWeight,vNode));
                }
            }
        }
        
        return sum;
    }
    
    static class Pair<K,V>{
        K key;
        V value;
        
        Pair(K key,V value){
            this.key = key;
            this.value = value;
        }
        
        K getKey(){
            return key;
        }
        
        V getValue(){
            return value;
        }
    }

7033.Kruskal's Algorithm / UnionByRank/ UnionBySize || Fundamental || **
TC:
SC:

class Solution {
    static int spanningTree(int V, int E, List<List<int[]>> adj) {
        int[] rank = new int[V];
        int[] parent = new int[V];
        
        for(int i = 0 ; i < V ; i++){
            parent[i] = i;
        }
        
        List<List<Integer>> edges = new ArrayList<>();
        for(int i = 0 ; i < adj.size(); i++){
            for(int[] edge : adj.get(i)){
                edges.add(new ArrayList<>(List.of(edge[1],i,edge[0])));
            }
        }
        
        Collections.sort(edges,(a,b) -> a.get(0)-b.get(0));
        int sum = 0;
        DisjointSet ds = new DisjointSet(V);
        
        for(int i = 0 ; i < edges.size(); i++){
            int w = edges.get(i).get(0);
            int u = edges.get(i).get(1);
            int v = edges.get(i).get(2);
            
            if(ds.findParent(u) != ds.findParent(v)){
                sum+=w;
                ds.unionBySize(u,v);
            }
        }
        
        return sum;
    }
    
    static class DisjointSet{
        int[] rank;
        int[] parent;
        int[] size;
        
        DisjointSet(int n){
            rank = new int[n];
            parent = new int[n];
            size = new int[n];
            
            for(int i = 0 ; i < n ; i++){
                rank[i] = 0;
                parent[i] = i;
                size[i] = 1;
            }
        }
        
        int findParent(int node){
            if(parent[node] == node) return node;
            return parent[node] = findParent(parent[node]);
        }
        
        void unionByRank(int u, int v){
            int p_u = findParent(u);
            int p_v = findParent(v);
            
            int r_u = rank[p_u];
            int r_v = rank[p_v];
            
            if(r_u < r_v){
                parent[p_u] = p_v;
            }else if(r_v < r_u){
                parent[p_v] = p_u;
            }else{
                parent[p_u] = p_v;
                rank[p_v]++;
            }
        }
        
        void unionBySize(int  u, int v){
            int p_u = findParent(u);
            int p_v = findParent(v);
            
            int s_u = size[p_u];
            int s_v = size[p_v];
            
            if(s_u < s_v){
                parent[p_u] = p_v;
                size[p_u] += size[p_v];
            }else{
                parent[p_v] = p_u;
                size[p_v] += size[p_u];
            }
        }
    }
}

7034. Number of operations to make network connected || EASY
class Solution {
    class DisjointSet{
        int[] rank;
        int[] parent;
        DisjointSet(int n){
            rank = new int[n];
            parent = new int[n];
            for(int i = 0 ; i < n ; i++){
                rank[i] = 0;
                parent[i] = i;        
            }
        }

        int findParent(int node){
            if(parent[node] == node) return node;
            return parent[node] = findParent(parent[node]);
        }

        void unionByRank(int u , int v){
            int p_u = parent[u];
            int p_v = parent[v];

            int r_u = rank[p_u];
            int r_v = rank[p_v];

            if(r_u < r_v){
                parent[p_u] = p_v;
            }else if(r_v < r_u){
                parent[p_v] = p_u;
            }else{
                parent[p_v] = p_u;
                rank[p_v]++;
            }
        }
    }
    public int makeConnected(int n, int[][] conn) {
        DisjointSet ds = new DisjointSet(n);

        for(int i = 0 ; i < conn.length ; i++){
            int u = conn[i][0];
            int v = conn[i][1];
            if(ds.findParent(u) != ds.findParent(v)){
                ds.unionByRank(u,v);
            }
        }

        int components = 0;
        for(int i = 0 ; i < n ; i++){
            if(ds.parent[i] == i){
                components++;
            }
        }

        return conn.length < n-1 ? -1 : components-1;

    }
}

7035. Most stones removed with same rows or columns || Medium || ***
class Solution {
    class DisjointSet{
        int[] rank;
        int[] parent;
        DisjointSet(int n){
            rank = new int[n];
            parent = new int[n];
            for(int i = 0 ; i < n ; i++){
                rank[i] = 0;
                parent[i] = i;        
            }
        }

        int findParent(int node){
            if(parent[node] == node) return node;
            return parent[node] = findParent(parent[node]);
        }

        void unionByRank(int u , int v){
            int p_u = parent[u];
            int p_v = parent[v];

            int r_u = rank[p_u];
            int r_v = rank[p_v];

            if(r_u < r_v){
                parent[p_u] = p_v;
            }else if(r_v < r_u){
                parent[p_v] = p_u;
            }else{
                parent[p_v] = p_u;
                rank[p_u]++;
            }
        }
    }
    public int removeStones(int[][] stones) {
        int n = stones.length;
        int maxRow = 0;
        int maxCol = 0;

        for(int i = 0 ; i < stones.length ; i++){
            maxRow = Math.max(maxRow,stones[i][0]);
            maxCol = Math.max(maxCol, stones[i][1]);
        }

        DisjointSet ds = new DisjointSet(maxRow + maxCol + 2);
        Set<Integer> st = new HashSet<>();
        for(int i = 0 ; i < stones.length ; i++){
            int row = stones[i][0];
            int col = stones[i][1] + maxRow + 1;

            if(ds.findParent(row) != ds.findParent(col)){
                ds.unionByRank(row,col);
            }
            st.add(row);
            st.add(col);
        }

        int comp = 0;
        for(int t : st){
            if(ds.findParent(t) == t) comp++;
        }
        return n - comp;
    }
}

7036. Accounts merge || MEDIUM || ***

class Solution {
    class DisjointSet{
        Map<String,Integer> rankMap;
        Map<String,String> parentMap;

        DisjointSet(){
            rankMap = new HashMap<>();
            parentMap = new HashMap<>();
        }

        void add(String email){
            parentMap.put(email,email);
            rankMap.put(email,0);
        }

        String findParent(String email){
            // if(!parentMap.containsKey(email)){
            //     parentMap.put(email,email);
            //     rankMap.put(email,0);
            // }

            if(parentMap.get(email).equals(email)) return email;
            String parent = findParent(parentMap.get(email));
            parentMap.put(email,parent);
            return parent;
        }

        void union(String u, String v){
            String p_u = findParent(u);
            String p_v = findParent(v);

            if(p_u.equals(p_v)) return;

            int r_u = rankMap.get(p_u);
            int r_v = rankMap.get(p_v);

            if(r_u < r_v){
                parentMap.put(p_u,p_v);
            }else if(r_v < r_u){
                parentMap.put(p_v,p_u);
            }else{
                parentMap.put(p_u,p_v);
                int rank = rankMap.get(p_v);
                rankMap.put(p_v,rank+1);
            }
        }
    }
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        Map<String,String> nameMap = new HashMap<>();
        Map<String,List<String>> emailMap = new HashMap<>();
        DisjointSet ds = new DisjointSet();

        for(List<String> account : accounts){
            nameMap.put(account.get(1), account.get(0));

            for(int i = 1 ; i < account.size(); i++){
                if(!ds.parentMap.containsKey(account.get(i))){
                    ds.add(account.get(i));
                }
                if(i >= 2){
                    ds.union(account.get(i),account.get(i-1));
                }
            }
        }

        for(Map.Entry<String,String> entry : ds.parentMap.entrySet()){
            String email = entry.getKey();
            String parent = ds.findParent(entry.getValue());
            
            if(emailMap.containsKey(parent)){
                emailMap.get(parent).add(email);
            }else{
                emailMap.put(parent, new ArrayList<>(List.of(email)));
            }
        }

        List<List<String>> ans = new ArrayList<>();
        for(String primaryEmail : emailMap.keySet()){
            List<String> emails = emailMap.get(primaryEmail);
            Collections.sort(emails);
            emails.add(0,nameMap.get(primaryEmail));
            ans.add(emails);
        }
        return ans;
    }
}

7038. Making a Large Island || MEDIUM || ***
class Solution {
    class DisjointSet{
        int[] parent;
        int[] size;

        DisjointSet(int n){
            parent = new int[n];
            size = new int[n];

            for(int i = 0 ; i < n ; i++){
                parent[i] = i;
                size[i] = 1;
            }
        }

        int findParent(int node){
            if(parent[node] == node) return node;
            return parent[node] = findParent(parent[node]);
        }

        void union(int u , int v){
            int p_u = findParent(u);
            int p_v = findParent(v);

            if(p_u == p_v) return;

            int s_u = size[p_u];
            int s_v = size[p_v];

            if(s_u < s_v){
                parent[p_u] = p_v;
                size[p_v] += size[p_u];
            }else{
                parent[p_v] = p_u;
                size[p_u] += size[p_v];
            }
        }
    }
    public int largestIsland(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;

        int[] dx = new int[]{1,-1,0,0};
        int[] dy = new int[]{0,0,1,-1};

        DisjointSet ds = new DisjointSet(row*col);
        int maxSize = 0;
        for(int i = 0 ; i < row ; i++){
            for(int j = 0 ; j < col ; j++){
                if(grid[i][j] == 1){
                    int a = (i * col) + j;
                    
                    for(int k = 0 ; k < 4 ; k++){
                        int adjRow = i + dx[k];
                        int adjCol = j + dy[k];

                        if(adjRow >= 0 && adjCol >= 0 && adjRow < row && adjCol < col && grid[adjRow][adjCol] == 1){
                            int b = adjRow * col + adjCol;
                            ds.union(a,b);
                        }
                    }
                }
            }
        }
        int maxIsland = 0;
        Set<Integer> st = new HashSet<>();
        boolean hasZero = false;
        for(int i = 0 ; i < row ; i++){
            for(int j = 0 ; j < col ; j++){
                if(grid[i][j] == 0){
                    hasZero = true;
                    int sum = 0;
                    
                    for(int k = 0 ; k < 4 ; k++){
                        int adjRow = i + dx[k];
                        int adjCol = j + dy[k];

                        if(adjRow >= 0 && adjCol >= 0 && adjRow < row && adjCol < col && grid[adjRow][adjCol] == 1){
                            int b = adjRow * col + adjCol;
                            st.add(ds.findParent(b));
                        }
                    }

                    for(int t : st){
                        sum += ds.size[t];
                    }
                    st.clear();
                    maxIsland = Math.max(sum+1,maxIsland);
                }
            }
        }

        if(!hasZero) return row * col;

        return maxIsland;
    }
}