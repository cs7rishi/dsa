1. Largest Element in Array
class Solution {
    public static int largest(int[] arr) {
        // code here
        int mx = Integer.MIN_VALUE;
        for(int t : arr) mx = Math.max(t,mx);
        return mx
    }
}


##### Medium ######
1.Two Sum

1.a TC: N^2
    SC: 0(1)

class Solution {
    public int[] twoSum(int[] nums, int target) {
        for(int i = 0 ; i < nums.length; i++){
            for(int j = i + 1 ; j < nums.length; j++){
                if(nums[i] + nums[j] == target) return new int[]{i,j};
            }
        }

        return new int[]{};
    }
}

1.b TC : O(n)
    SC : O(n)

class Solution {
    public int[] twoSum(int[] nums, int target) {
        //Integer,Index
        Map<Integer,Integer> mp = new HashMap<>();
        for(int i = 0 ; i < nums.length; i++){
            int required = target - nums[i];
            if(mp.containsKey(required)){
                return new int[]{mp.get(required),i};
            }

            mp.put(nums[i],i);
        }

        return new int[]{};
    }
}

2. Sort Colors
0.... low - 1 => 0
low ..... mid-1 => 1
high+1 .....n-1 => 2
 class Solution {
    private void swap(int[] nums, int i , int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
    public void sortColors(int[] nums) {
        int low = -1;
        int mid = 0;
        int high = nums.length-1;

        while(mid <= high){
            if(nums[mid] == 0){
                low++;
                swap(nums,low,mid);
                mid++;
            }else if(nums[mid] == 1){
                mid++;
            }else{
                swap(nums, mid, high);
                high--;
            }
        }

        System.out.println(Arrays.toString(nums));
    }
}

3.Majority Element
class Solution {
    public int majorityElement(int[] nums) {
        int ele = 0;
        int count = 0;

        for(int t : nums){
            if(count == 0){
                ele = t;
                count = 1;
            }else{
                if(ele == t){
                    count++;
                }else{
                    count--;
                }
            }
        }
        return ele;
    }
}

4.Maximum Subarray
class Solution {
    public int maxSubArray(int[] nums) {
        int INF = -10000;
        int ms = INF;
        int meh = INF;

        for(int i = 0 ; i < nums.length ; i++){
            meh = Math.max(meh + nums[i], nums[i]);
            ms = Math.max(meh, ms);
        }

        return ms;
    }
}

5.Leaders in an Array problem
class Solution {
    static ArrayList<Integer> leaders(int arr[]) {
        Stack<Integer> st = new Stack<>();
        for(int i = arr.length-1 ; i >= 0 ; i--){
            if(st.isEmpty() || st.peek() <= arr[i]){
                st.push(arr[i]);
            }
        }
        ArrayList<Integer> ans = new ArrayList<>();
        while(!st.isEmpty()){
            ans.add(st.pop());
        }
        
        return ans;
    }
}


6.Longest Consecutive Sequence in an Array *** 

6.a. TC: O(nlogn + n)
     SC: O(1)
class Solution {
    public int findLongestConseqSubseq(int[] arr) {
        Arrays.sort(arr);
        int ans = 1;
        int meh = 1;
        for(int i = 1 ; i < arr.length ; i++){
            if(arr[i] == arr[i-1]) continue;
            else if(arr[i]-arr[i-1] == 1){
                meh++;
            }else{
                ans = Math.max(ans,meh);
                meh = 1;
            }
        }
        ans = Math.max(ans,meh);
        return ans;
    }
}

6.b TC: O(n + n)
    SC: O(n)
class Solution {
    public int findLongestConseqSubseq(int[] arr) {
        Set<Integer> st = new HashSet<>();
        for(int i: arr){
            st.add(i);
        }
        int ans = 1;
        for(int i: arr){
            if(!st.contains(i-1)){
                int num = i;
                int count = 1;
                while(st.contains(num+1)){
                    count++;
                    num++;
                }
                ans = Math.max(count,ans);
            }
        }
        return ans;
    }
}

7.Set Matrix Zeroes *
7.a TC: O(2*n*m)
    SC: O(n+m)
class Solution {
    public void setZeroes(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int[] row = new int[n];
        int[] col = new int[m];
        for(int i = 0 ; i < n ; i++){
            for(int j = 0 ; j < m ; j++){
                if(matrix[i][j] == 0){
                    row[i] = -1;
                    col[j] = -1;
                }
            }
        } 
        for(int i = 0; i < n ; i++){
            for(int j = 0 ; j < m ; j++){
                if(row[i] == -1 || col[j] == -1){
                    matrix[i][j] = 0;
                }
            }
        }
    }
}

7.b TC: O(2*n*m)
    SC: O(1)

class Solution {
    public void setZeroes(int[][] matrix) {
        int zeroCol = 1;
        int n = matrix.length;
        int m = matrix[0].length;
        for(int i = 0; i < n ; i++){
            for(int j = 0 ; j < m ; j++){
                if(matrix[i][j] == 0){
                    if(j == 0){
                        zeroCol = 0;
                        matrix[i][0] = 0;
                    }else{
                         matrix[i][0] = 0;
                        matrix[0][j] = 0;
                    }
                }                
            }
        }

        for(int i = 1 ; i < n ; i++){
            for(int j = 1 ; j < m ; j++){
                if(matrix[i][0] == 0 || matrix[0][j] == 0){
                    matrix[i][j] = 0;
                }
            }
        }
        //If initially filled these inidices, whole matrix could become zero
        if(matrix[0][0] == 0) Arrays.fill(matrix[0],0);

        if(zeroCol == 0){
            for(int i = 0 ; i < n ; i++){
                matrix[i][0] = 0;
            }
        }

    }
}

9. Rotate Array
9.a TC: O(2*n)
    SC: O(n)
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;

        int[] ans = new int[n];
        for(int i= 0 ; i < n ; i++){
            int j = (i + k) % n;
            System.out.println(i + " " + j);
            ans[j] = nums[i];
        }

        for(int i = 0 ; i < n ; i++){
            nums[i] = ans[i];
        }
    }
}

9.b TC: O(n)
    SC: O(1)

class Solution {
    private void reverse(int[] array, int i ,int j){
        int low = i ;
        int high = j;

        while(low <= high){
            int t = array[low];
            array[low] = array[high];
            array[high] = t;

            low++;
            high--;
        }
    }
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k%=n;
        reverse(nums, 0,n-k-1);
        reverse(nums, n-k, n-1);
        reverse(nums,0,n-1);
    }
}

11. Longest subarray with sum K (Positives + Negatives)
//Prefix Map
TC: O(n)
SC: O(n) 

class Solution {
    public static int lenOfLongSubarr(int A[], int N, int K) {
        Map<Integer,Integer> prefixMap = new HashMap<>();
        int prefixSum = 0;
        int ans = 0;
        prefixMap.put(prefixSum, -1);
        for(int i = 0 ; i < N ; i++){
            prefixSum += A[i];
            int subtract = prefixSum - K;
            if(prefixMap.containsKey(subtract)){
                ans = Math.max(ans, i - prefixMap.get(subtract));
            }   
            if(!prefixMap.containsKey(prefixSum)){
                prefixMap.put(prefixSum,i);
            }
        }
        return ans;
    }
}

12. 12. Subarray Sum Equals K
//Prefix Map
TC: O(n)
SC: O(n) 

class Solution {
    public int subarraySum(int[] nums, int k) {
        //sum, count
        Map<Long,Integer> preMap = new HashMap<>();
        preMap.put(0L,1);
        long preSum = 0L;
        int subCount = 0;
        for(int i : nums){
            preSum += i;
            long subtract = preSum - k;

            if(preMap.containsKey(subtract)){
                subCount += preMap.get(subtract);
            }

            preMap.put(preSum, preMap.getOrDefault(preSum,0)+1);
        }

        return subCount;
    }
}


13. Majority Element II

TC : O(n + n)
SC : O(1)
    public List<Integer> majorityElement(int[] nums) {
        int INF = 1000_000_001;
        int count_a = 0;
        int a = INF;
        int count_b = 0;
        int b = INF;

        for(int i : nums){
            if(count_a == 0 && i != b){
                a = i;
            }else if(count_b == 0 && i != a){
                b = i;
            }

            if(i == a){
                count_a++;
            }else if(i == b){
                count_b++;
            }else{
                count_a--;
                count_b--;
            }
        }

        count_a = 0;
        count_b = 0;

        for(int i : nums){
            if(i == a) count_a++;
            else if(i == b) count_b++;
        }

        int mn = (int)(nums.length / 3)+1;
        List<Integer> ans = new ArrayList<>();
        if(count_a >= mn) ans.add(a);
        if(count_b >= mn) ans.add(b);


        return ans;
    }

14. 3Sum

14.a 
TC: O(n^3*log(k) k is no. of unique triplet, not considering the time complexity of sorting the element)
SC: O(2*k) k is unique triplet

public List<List<Integer>> threeSum(int[] nums) {
    Set<List<Integer>> st = new HashSet<>();
    for(int i = 0 ; i < nums.length ; i++){
        for(int j = i+1 ; j < nums.length ; j++){
            for(int k = j+1; k < nums.length ; k++){
                if(nums[i] + nums[j] + nums[k] == 0){
                    List<Integer> arr = new ArrayList<>(List.of(nums[i], nums[j], nums[k]));
                    Collections.sort(arr);
                    st.add(arr);
                }
            }
        }
    }
    List<List<Integer>> ans = new ArrayList<>();
    for(List<Integer> list : st){
        ans.add(list);
    }
    return ans;
}

14.b
TC: O(n^2*log(k), k is unique triplet, log(k) required to add in the set)
SC: O(k(st) + k(arr) + n(preSet))
public List<List<Integer>> threeSum(int[] nums) {
    Set<List<Integer>> st = new HashSet<>();
    for(int i = 0 ; i < nums.length ; i++){
        Set<Integer> preSet = new HashSet<>();
        for(int j = i+1 ; j < nums.length ; j++){
            int required = -(nums[i] + nums[j]);
            if(preSet.contains(required)){
                List<Integer> arr = new ArrayList<>(List.of(nums[i], nums[j], required));
                Collections.sort(arr);
                st.add(arr); //contribute toward complexity
            }
            preSet.add(nums[j]);
        }
    }
    List<List<Integer>> ans = new ArrayList<>(st); <<<<<<<<<<<<<<<<< how 2d list is created from set
    return ans;
}

14.c
TC: O(n^2)
SC: O(k , where k is all the triplets)
//Handle the case of duplicates

    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        for(int i = 0 ; i < n ; i++){
            
            int low = i + 1;
            int high = n - 1;

            while(low < high){
                int sum = nums[low] + nums[high];
                if(sum == -nums[i]){
                    ans.add(List.of(nums[i],nums[low],nums[high]));
                    while(low < high && nums[low+1] == nums[low]){
                        low++;
                    }
                    low++;
                    while(low < high && nums[high-1] == nums[high]){
                        high--;
                    }
                    high--;
                }else if(sum > -nums[i]){
                    high--;
                }else{
                    low++;
                }
            }
            while(i < n && i+1 < n && nums[i+1] == nums[i]){
                i++;
            }
        }
        return ans;
    }



15. Largest subarray with 0 sum
TC: O(n)
SC: O(n)
    int maxLen(int arr[], int n)
    {
        Map<Integer,Integer> mp = new HashMap<>();
        mp.put(0,-1);
        int preSum = 0;
        int ans = 0;
        for(int i = 0; i < arr.length ; i++){
            preSum += arr[i];
            
            if(mp.containsKey(preSum)){
                ans = Math.max(ans, i - mp.get(preSum));
            }
            
            if(mp.get(preSum) == null){
                mp.put(preSum, i);
            }
        }
        
        return ans;
    }


16. Subarray with given XOR
    public int solve(int[] A, int B) {
        Map<Integer,Integer> mp = new HashMap<>();
        mp.put(0,1); <<<<<<<<<<<<<<<< important
        int count = 0;
        int preXor = 0;
        for(int i = 0 ; i < A.length ; i++){
            preXor ^= A[i];
            int required = preXor ^ B;
            
            count+= mp.getOrDefault(required,0);
        
            mp.put(preXor, mp.getOrDefault(preXor,0)+1);
        }
        
        return count;
    }

17. 4Sum
17.a
TC: O(n^4*log(k), where k is no of the quadraple)
SC: O(2*k)

    public List<List<Integer>> fourSum(int[] nums, int target) {
        int n = nums.length;
        Set<List<Integer>> st = new HashSet<>();
        for(int i = 0 ; i < n ; i++){
            for(int j = i+1 ; j < n ; j++){
                for(int k = j+1 ; k < n ; k++){
                    for(int l = k+1 ; l < n ; l++){
                        if(nums[i] + nums[j] + nums[k] + nums[l] == target){
                            List<Integer> list = new ArrayList<>(List.of(nums[i], nums[j], nums[k], nums[l]));
                            Collections.sort(list);
                            st.add(list);
                        }
                    }
                }
            }
        }
        List<List<Integer>> ans = new ArrayList<>(st);
        return ans;
    }

17.b //take care of long numbers;
TC: O(n^3*logk)
SC: O(k)
    public List<List<Integer>> fourSum(int[] nums, int target) {
        int n = nums.length;
        Set<List<Integer>> ansSet = new HashSet<>();
        for(int i = 0 ; i < n ; i++){
            for(int j = i+1 ; j < n ; j++){
                long total = target - (long)nums[i] - (long)nums[j];
                Set<Long> hashSet = new HashSet<>();
                for(int k = j+1 ; k < n ; k++){
                    long required = total - (long)nums[k];
                    if(hashSet.contains(required)){
                        List<Integer> list = new ArrayList<>(List.of(nums[i], nums[j], nums[k] , (int)required));
                        Collections.sort(list);
                        ansSet.add(list);
                    }
                    hashSet.add((long)nums[k]);
                }
            }
        }
        List<List<Integer>> ans = new ArrayList<>(ansSet);
        return ans;
    }

17.c
TC: O(n^3)
SC: O(k)

public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        for(int i = 0 ; i < nums.length ; i++){
            for(int j = i+1 ; j < nums.length ; j++){
                long total = target - (long) nums[i] - (long) nums[j];
                int low = j + 1 , high = nums.length - 1;
                while(low < high){
                    // System.out.println(low + " " + high);
                    long sum = (long)nums[low] + (long)nums[high];
                    if(sum == total){
                        List<Integer> list = new ArrayList<>(List.of(nums[i],nums[j], nums[low],nums[high]));
                        ans.add(list);
                        while(low < high && low + 1 < high && nums[low] == nums[low+1])low++;
                        while(low < high && low < high - 1 && nums[high-1] == nums[high])high--;
                        low++;
                        high--;
                    }else if(sum < total){
                        low++;
                    }else{
                        high--;
                    }
                }
                while(j < nums.length && j + 1 < nums.length && nums[j] == nums[j+1]) j++;
            }
            while(i < nums.length && i + 1 < nums.length && nums[i] == nums[i+1]) i++;
        }
        return ans;
    }