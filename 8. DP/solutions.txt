8001. Climbing Stars || EASY
    public int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;

        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;

        for(int i = 2 ; i < n ; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n-1];
    }

8002. Frog Jump || EASY || *
    public int minimumEnergy(int arr[],int n){
        
        int[] dp = new int[n];
        dp[0] = 0;
        if(n==1) return dp[0];
        dp[1] = Math.abs(arr[1]-arr[0]); //************ can reach from 1 step only, not from ground
        if(n==2) return dp[1];
        
        for(int i = 2 ; i < n ; i++){
            dp[i] = Math.min(
                dp[i-1] + Math.abs(arr[i-1] - arr[i]),
                dp[i-2] + Math.abs(arr[i-2] - arr[i])
                );
            
        }
        
        return dp[n-1];
        
    }

8003. Frog Jump with k distances
public int minimizeCost(int k, int arr[]) {
        int n = arr.length;
        int[] dp = new int[n];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 0 ; i < n ; i++){
            for(int j = i+1 ; j <= i+k && j < n ; j++){
                dp[j] = Math.min(dp[j], dp[i] + Math.abs(arr[j] - arr[i]));
            }
        }
        return dp[n-1];
    }


8004. Maximum sum of non-adjacent elements || EASY
    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];

        dp[0] = nums[0];
        if(n == 1) return dp[0];

        dp[1] = Math.max(nums[0], nums[1]);
        if(n == 2) return dp[1];

        for(int i = 2 ; i < n ; i++){
            dp[i] = Math.max(nums[i] + dp[i-2] , dp[i-1]);
        } 

        return dp[n-1];
    }

8006. Ninja's Training
    public int maximumPoints(int arr[][], int n) {
        int[][] dp = new int[n][3];
        dp[0][0] = arr[0][0];
        dp[0][1] = arr[0][1];
        dp[0][2] = arr[0][2];
        
        for(int i = 1 ; i < n ; i++){
            dp[i][0] = arr[i][0] + Math.max(dp[i-1][1], dp[i-1][2]);
            dp[i][1] = arr[i][1] + Math.max(dp[i-1][2], dp[i-1][0]);
            dp[i][2] = arr[i][2] + Math.max(dp[i-1][0], dp[i-1][1]);
        }
        return Math.max(dp[n-1][0] , Math.max(dp[n-1][1], dp[n-1][2]));
    }

8007. Grid Unique Paths : DP on Grids
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for(int i = 0 ; i < m ; i++){
            for(int j = 0 ; j < n ; j++){
                if(i == 0 || j == 0){
                    dp[i][j] = 1;
                }else{
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }

        return dp[m-1][n-1];
    }

8008. Grid Unique Paths 2
    public int uniquePathsWithObstacles(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0] == 1 ? 0 : 1;
        for(int i = 1 ; i < m ; i++){
            if(grid[i][0] == 1) break;
            else dp[i][0] = 1;
        }
        for(int j = 1 ; j < n ; j++){
            if(grid[0][j] == 1) break;
            else dp[0][j] = 1;
        }
        for(int i = 1 ; i < m ; i++){
            for(int j = 1 ; j < n ; j++){
                if(grid[i][j] == 1){
                    dp[i][j] = 0;
                }else{
                    dp[i][j] = dp[i][j-1] + dp[i-1][j];
                }
            }
        }

        return dp[m-1][n-1];
    }

8009. Minimum path sum in Grid
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        for(int i = 1 ; i < m ; i++){
            grid[i][0] = grid[i][0] + grid[i-1][0];
        }
        for(int j = 1 ; j < n ; j++){
            grid[0][j] = grid[0][j] + grid[0][j-1];
        }
        for(int i = 1 ; i < m ; i++){
            for(int j = 1 ; j < n ; j++){
                grid[i][j] = grid[i][j] + Math.min(grid[i-1][j] , grid[i][j-1]);
            }
        }
        return grid[m-1][n-1];
    }